<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>詰将棋練習アプリ</title>
    <style>
        body {
            font-family: 'Hiragino Sans', 'Noto Sans JP', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            box-sizing: border-box;
        }

        * {
            box-sizing: border-box;
        }

        .app-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .app-main-content {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .app-board-section {
            flex: 1;
            min-width: 350px;
        }

        .app-controls-section {
            flex: 1;
            min-width: 300px;
        }

        .app-board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 auto 10px;
        }

        .app-board-with-coords {
            display: grid;
            grid-template-columns: repeat(9, 1fr) 30px;
            grid-template-rows: 30px repeat(9, 1fr);
            width: 350px;
            height: 350px;
            border: 3px solid #8B4513;
            background: #DEB887;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            border-radius: 8px;
        }

        .app-coord-label {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            color: #8B4513;
            background: #F5DEB3;
        }

        .app-coord-corner {
            background: #DEB887;
        }

        .app-cell {
            border: 1px solid #8B4513;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.15s ease;
            background: #F5DEB3;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .app-cell:hover {
            background: #FFE4B5;
        }

        @media (hover: none) and (pointer: coarse) {
            .app-cell:hover {
                background: #F5DEB3;
                transform: none;
            }
            .app-cell:active {
                background: #FFE4B5;
            }
        }

        .app-piece {
            font-size: 20px;
            font-weight: bold;
        }

        .app-piece.sente {
            color: #FF4444; /* Red for Sente */
        }

        .app-piece.gote {
            color: #4444FF; /* Blue for Gote */
        }

        /* Class for 180 degree rotation, applied conditionally */
        .app-piece.rotated-graphic {
            transform: rotate(180deg);
        }

        .app-player-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 8px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .app-player-toggle span:first-child {
            min-width: 80px; 
            white-space: nowrap;
        }

        .app-toggle-switch {
            position: relative;
            width: 60px;
            height: 30px;
            background: #ccc;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            user-select: none;
        }

        .app-toggle-switch:hover {
            background: #bbb;
        }

        .app-toggle-switch.active {
            background: #4CAF50;
        }

        .app-toggle-switch::after {
            content: '';
            position: absolute;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: white;
            top: 2px;
            left: 2px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .app-toggle-switch.active::after {
            left: 32px;
        }

        .app-pieces-palette {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 4px;
            margin-bottom: 10px;
            padding: 8px;
            background: linear-gradient(45deg, #f0f0f0, #e0e0e0);
            border-radius: 8px;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.1);
        }

        .app-piece-btn {
            padding: 8px 4px;
            border: 2px solid #666;
            background: #fff;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            border-radius: 6px;
            transition: background-color 0.15s ease;
            min-height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .app-piece-btn:hover {
            background: #e0e0ff;
        }

        @media (hover: none) and (pointer: coarse) {
            .app-piece-btn:hover {
                background: #fff;
                transform: none;
                box-shadow: none;
            }
            .app-piece-btn:active {
                background: #e0e0ff;
            }
        }

        .app-piece-btn.selected {
            background: #4CAF50;
            color: white;
            border-color: #45a049;
        }

        .app-piece-btn.special-blue {
            background: #e3f2fd;
            border-color: #2196f3;
        }

        .app-piece-btn.special-yellow {
            background: #fff9c4;
            border-color: #ff9800;
        }

        .app-piece-btn.special-red {
            background: #ffebee;
            border-color: #f44336;
        }

        .app-piece-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #f5f5f5 !important;
            border-color: #ccc !important;
        }

        .app-piece-btn.disabled:hover {
            transform: none !important;
            box-shadow: none !important;
        }

        .app-captured-pieces {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 10px;
        }

        .app-captured-section {
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: linear-gradient(45deg, #f8f9fa, #ffffff);
        }

        .app-captured-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .app-captured-section h3 {
            margin: 0;
            font-size: 14px;
        }

        .app-clear-captured-btn {
            padding: 2px 6px;
            border: 1px solid #ccc;
            background: #f8f9fa;
            cursor: pointer;
            font-size: 10px;
            border-radius: 4px;
            transition: all 0.2s ease;
            color: #666;
        }

        .app-clear-captured-btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
        }

        .app-captured-pieces-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 40px;
            align-items: center;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .app-captured-pieces-list:hover {
            background-color: rgba(0, 0, 255, 0.05);
        }

        .app-captured-piece {
            padding: 5px 10px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.15s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .app-captured-piece:hover {
            background: #ffeeee;
        }

        @media (hover: none) and (pointer: coarse) {
            .app-captured-piece:hover {
                background: #fff;
                transform: none;
            }
            .app-captured-piece:active {
                background: #ffeeee;
            }
        }

        .app-captured-piece.sente {
            color: #FF4444;
        }

        .app-captured-piece.gote {
            color: #4444FF;
        }

        .app-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .app-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.2s ease;
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        @media (hover: none) and (pointer: coarse) {
            .app-btn:hover {
                transform: none;
                box-shadow: 0 3px 10px rgba(0,0,0,0.2);
            }
            .app-btn:active {
                transform: translateY(1px);
            }
        }

        .app-btn-primary {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
        }

        .app-btn-share {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .app-btn-secondary {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
            color: white;
        }

        .app-btn-warning {
            background: linear-gradient(45deg, #fdcb6e, #e17055);
            color: white;
        }

        .app-btn-danger {
            background: linear-gradient(45deg, #fd79a8, #e84393);
            color: white;
        }

        .app-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .app-sfen-output {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .app-sfen-text {
            font-family: monospace;
            font-size: 14px;
            word-break: break-all;
            background: white;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            margin-top: 10px;
        }
        
        .app-analysis-output {
            margin-top: 20px;
            padding: 15px;
            background: #e6f7ff; /* Light blue background for analysis */
            border-radius: 8px;
            border: 1px solid #91d5ff; /* Blue border */
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            font-size: 14px;
            line-height: 1.6;
            color: #333;
        }

        .app-analysis-output h4 {
            margin-top: 0;
            color: #1890ff; /* Darker blue for heading */
            font-size: 16px;
            border-bottom: 1px solid #bae7ff;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }

        .app-analysis-output p {
            margin-bottom: 10px;
        }

        .app-analysis-output p:last-child {
            margin-bottom: 0;
        }

        .app-analysis-output.loading {
            text-align: center;
            font-style: italic;
            color: #666;
        }


        .app-message {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            background: #4CAF50;
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            max-width: 90vw;
            text-align: center;
            font-size: 14px;
        }

        .app-message.show {
            opacity: 1;
        }

        .app-message.error {
            background: #f44336;
        }

        .app-message.warning {
            background: #ff9800;
        }

        .app-cell.invalid {
            background: #ffcdd2 !important;
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .app-cell.pickup-source {
            background: #ffeb3b !important;
            box-shadow: inset 0 0 15px rgba(255,193,7,0.6);
            animation: pulse 1.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            0% { box-shadow: inset 0 0 15px rgba(255,193,7,0.6); }
            100% { box-shadow: inset 0 0 20px rgba(255,193,7,0.9); }
        }

        .app-piece-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 16px;
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            opacity: 0;
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
            max-width: 90vw;
            text-align: center;
        }

        .app-piece-indicator:hover {
            background: #ffeaa7;
            border-color: #fdcb6e;
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .app-piece-indicator::after {
            content: '(タップで削除)';
            display: block;
            font-size: 11px;
            color: #666;
            margin-top: 2px;
            font-weight: normal;
        }

        .app-piece-indicator.show {
            opacity: 1;
        }

        .app-return-to-palette-btn {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 20px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            opacity: 0;
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
            max-width: 90vw;
            text-align: center;
            display: none;
        }

        .app-return-to-palette-btn:hover {
            background: linear-gradient(45deg, #ff5252, #d32f2f);
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        .app-return-to-palette-btn.show {
            opacity: 1;
            display: block;
        }

        .app-turn-dialog, .app-promote-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .app-turn-dialog.show, .app-promote-dialog.show {
            opacity: 1;
        }

        .app-turn-dialog-content, .app-promote-dialog-content {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 90%;
            width: 300px;
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }

        .app-turn-dialog.show .app-turn-dialog-content, .app-promote-dialog.show .app-promote-dialog-content {
            transform: translateY(0);
        }

        .app-turn-dialog-header, .app-promote-dialog-header {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }

        .app-turn-dialog-buttons, .app-promote-dialog-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .app-turn-btn, .app-promote-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background 0.3s ease, transform 0.2s ease;
            flex: 1;
            max-width: 120px;
        }

        .app-turn-btn.sente {
            background: linear-gradient(45deg, #f44336, #ef5350);
            color: white;
        }

        .app-turn-btn.sente:hover {
            background: linear-gradient(45deg, #e53935, #e53935);
            transform: translateY(-2px);
        }

        .app-turn-btn.gote {
            background: linear-gradient(45deg, #2196f3, #42a5f5);
            color: white;
        }

        .app-turn-btn.gote:hover {
            background: linear-gradient(45deg, #1e88e5, #1e88e5);
            transform: translateY(-2px);
        }

        .app-promote-btn:first-child {
            background: linear-gradient(45deg, #4CAF50, #66BB6A);
            color: white;
        }

        .app-promote-btn:first-child:hover {
            background: linear-gradient(45deg, #45a049, #5cb860);
            transform: translateY(-2px);
        }

        .app-promote-btn:last-child {
            background: linear-gradient(45deg, #FF9800, #FFB74D);
            color: white;
        }

        .app-promote-btn:last-child:hover {
            background: linear-gradient(45deg, #fb8c00, #ffa726);
            transform: translateY(-2px);
        }

        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            .app-container {
                padding: 10px;
            }
            
            .app-main-content {
                flex-direction: column;
                gap: 15px;
            }
            
            .app-board-section, .app-controls-section {
                min-width: unset;
            }
            
            .app-board-with-coords {
                width: min(85vw, 280px); 
                height: min(85vw, 280px);
                margin: 0 auto 10px;
            }
            
            .app-player-toggle {
                padding: 6px;
                margin-bottom: 8px;
            }
            
            .app-pieces-palette {
                grid-template-columns: repeat(4, 1fr);
                gap: 4px;
                padding: 8px;
                margin-bottom: 10px;
            }
            
            .app-piece-btn {
                padding: 4px 2px;
                font-size: 11px;
                min-height: 28px;
            }

            .app-piece {
                font-size: 16px; 
            }
            .app-cell {
                font-size: 14px;
            }
            .app-coord-label {
                font-size: 11px;
            }
            
            .app-captured-pieces {
                margin-bottom: 8px;
            }
            
            .app-captured-section {
                padding: 6px;
            }
            
            .app-captured-section h3 {
                font-size: 13px;
            }
            
            .app-controls {
                gap: 6px;
            }
            
            .app-btn {
                padding: 8px 12px;
                font-size: 13px;
            }
            
            .app-sfen-output {
                margin-top: 15px;
                padding: 12px;
            }
            
            .app-sfen-text {
                font-size: 12px;
                padding: 8px;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 3px;
            }
            
            .app-container {
                padding: 8px;
            }
            
            .app-main-content {
                gap: 10px;
            }
            
            .app-board-with-coords {
                width: min(90vw, 260px); 
                height: min(90vw, 260px);
                margin: 0 auto 8px;
            }
            
            .app-player-toggle {
                padding: 4px;
                margin-bottom: 6px;
                font-size: 13px;
            }
            
            .app-pieces-palette {
                grid-template-columns: repeat(3, 1fr);
                gap: 3px;
                padding: 6px;
                margin-bottom: 8px;
            }
            
            .app-piece-btn {
                padding: 3px 1px;
                font-size: 10px;
                min-height: 26px;
            }

            .app-piece {
                font-size: 14px; 
            }
            .app-cell {
                font-size: 12px;
            }
            .app-coord-label {
                font-size: 10px;
            }
            
            .app-captured-pieces {
                margin-bottom: 6px;
            }
            
            .app-captured-section {
                padding: 4px;
            }
            
            .app-captured-section h3 {
                font-size: 12px;
            }
            
            .app-controls {
                gap: 4px;
            }
            
            .app-btn {
                padding: 6px 10px;
                font-size: 12px;
            }
            
            .app-sfen-output {
                margin-top: 10px;
                padding: 10px;
            }
            
            .app-sfen-text {
                font-size: 11px;
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="app-main-content">
            <div class="app-board-section" id="appBoardSection">
                </div>
            
            <div class="app-controls-section">
                <div class="app-player-toggle">
                    <span>配置する駒:</span>
                    <span id="appPlayerLabel">先手</span>
                    <div class="app-toggle-switch" id="appPlayerToggle"></div>
                </div>
                
                <div class="app-player-toggle">
                    <span>駒の成り:</span>
                    <span id="appPromoteLabel">成らない</span>
                    <div class="app-toggle-switch active" id="appPromoteToggle"></div>
                </div>
                
                <div class="app-pieces-palette" id="appPiecesPalette"></div>
                
                <div class="app-captured-pieces">
                    <div class="app-captured-section">
                        <div class="app-captured-header">
                            <h3>先手持ち駒</h3>
                            <button class="app-clear-captured-btn" id="appClearSenteBtn">クリア</button>
                        </div>
                        <div class="app-captured-pieces-list" id="appSenteCaptured"></div>
                    </div>
                    <div class="app-captured-section">
                        <div class="app-captured-header">
                            <h3>後手持ち駒</h3>
                            <button class="app-clear-captured-btn" id="appClearGoteBtn">クリア</button>
                        </div>
                        <div class="app-captured-pieces-list" id="appGoteCaptured"></div>
                    </div>
                </div>
                
                <div class="app-controls">
                    <button class="app-btn app-btn-primary" id="appCopySfenBtn">SFENをコピー</button>
                    <button class="app-btn app-btn-primary" id="appImportSfenBtn">SFENをインポート</button>
                    <button class="app-btn app-btn-share" id="appGenerateShareBtn">共有URLを生成</button>
                    <button class="app-btn app-btn-warning" id="appPiyoshogiBtn">ぴよ将棋リンク生成</button>
                    <button class="app-btn app-btn-secondary" id="appInitialPositionBtn">初期配置で並べる</button>
                    <button class="app-btn app-btn-secondary" id="appMoveRemainingBtn">余り駒を後手持ち駒に</button>
                    <button class="app-btn app-btn-secondary" id="appFlipBoardBtn">盤面反転</button>
                    <button class="app-btn app-btn-danger" id="appClearBoardBtn">クリア</button>
                </div>
                
                <div class="app-sfen-output">
                    <strong>SFEN文字列:</strong>
                    <div class="app-sfen-text" id="appSfenText">局面を作成してください</div>
                </div>
            </div>
        </div>
    </div>

    <div class="app-message" id="appMessage"></div>

    <button class="app-return-to-palette-btn" id="appReturnToPaletteBtn">パレットに戻す</button>

    <div class="app-turn-dialog" id="appTurnDialog" style="display: none;">
        <div class="app-turn-dialog-content">
            <div class="app-turn-dialog-header">手番を選択してください</div>
            <div class="app-turn-dialog-buttons">
                <button class="app-turn-btn sente" id="appTurnSenteBtn">先手番</button>
                <button class="app-turn-btn gote" id="appTurnGoteBtn">後手番</button>
            </div>
        </div>
    </div>

    <div class="app-promote-dialog" id="appPromoteDialog" style="display: none;">
        <div class="app-promote-dialog-content">
            <div class="app-promote-dialog-header">駒を成りますか？</div>
            <div class="app-promote-dialog-buttons">
                <button class="app-promote-btn" id="appPromoteYesBtn">成る</button>
                <button class="app-promote-btn" id="appPromoteNoBtn">成らない</button>
            </div>
        </div>
    </div>

    <script>
        // Definition of basic variables and data structures
        const appPieces = {
            'P': '歩', 'L': '香', 'N': '桂', 'S': '銀', 'G': '金', 'B': '角', 'R': '飛', 'K': '玉',
            '+P': 'と', '+L': '杏', '+N': '圭', '+S': '全', '+B': '馬', '+R': '竜'
        };

        const appSfenPieceOrder = ['R', 'B', 'G', 'S', 'N', 'L', 'P'];
        const appMaxPieces = { 'P': 18, 'L': 4, 'N': 4, 'S': 4, 'G': 4, 'B': 2, 'R': 2, 'K': 2 };
        const appMaxKingPerPlayer = 1;

        // Application state variables
        let appCurrentPlayer = true; // true: Sente (first player), false: Gote (second player)
        let appSelectedPiece = null; // Piece selected from the palette
        let appBoard = Array(9).fill(null).map(() => Array(9).fill(null)); // Board state
        let appCapturedPieces = { sente: {}, gote: {} }; // Captured pieces
        let appAudioContext = null;
        let appSoundEnabled = true; // Sound enabled/disabled state
        let appPickedUpPiece = null; // Information about a piece picked up from the board
        let appAutoPromoteEnabled = true; // true: Don't promote unless forced
        let appPendingExportAction = null; // For turn selection during SFEN export
        let appPendingPromotion = null; // Piece information waiting for promotion decision
        let appBoardFlipped = false; // Tracks if the board is currently flipped

        // Message display function
        function appShowMessage(text, type = 'success') {
            const message = document.getElementById('appMessage');
            message.textContent = text;
            message.className = `app-message ${type}`;
            message.classList.add('show');
            
            setTimeout(() => {
                message.classList.remove('show');
            }, 3000);
        }

        // Piece selection handling
        function appSelectPiece(pieceKey, btnElement) {
            // Check if piece is disabled
            if (btnElement.classList.contains('disabled')) {
                appShowMessage('この駒はもう配置できません', 'warning');
                return;
            }
            
            appPlayPieceSound();
            document.querySelectorAll('.app-piece-btn').forEach(btn => btn.classList.remove('selected'));
            appSelectedPiece = pieceKey;
            btnElement.classList.add('selected');
            appShowMessage(`${appPieces[pieceKey]}を選択しました - 盤面をクリックで配置、持ち駒エリアをクリックで持ち駒に追加`);
        }

        // Function to create the Shogi board
        function appCreateBoard() {
            const boardSection = document.getElementById('appBoardSection');
            const existingBoard = boardSection.querySelector('.app-board-container');
            if (existingBoard) {
                existingBoard.remove();
            }
            
            const boardContainer = document.createElement('div');
            boardContainer.className = 'app-board-container';
            
            const boardWithCoords = document.createElement('div');
            boardWithCoords.className = 'app-board-with-coords';
            
            // Top column numbers (筋) - Change based on flip state
            const sujiLabels = appBoardFlipped ? 
                ['１', '２', '３', '４', '５', '６', '７', '８', '９'] :
                ['９', '８', '７', '６', '５', '４', '３', '２', '１'];
            
            for (let col = 0; col < 9; col++) {
                const colLabel = document.createElement('div');
                colLabel.className = 'app-coord-label';
                colLabel.textContent = sujiLabels[col];
                boardWithCoords.appendChild(colLabel);
            }
            
            // Top-right corner (empty)
            const rightCorner = document.createElement('div');
            rightCorner.className = 'app-coord-label app-coord-corner';
            boardWithCoords.appendChild(rightCorner);
            
            // Create each row
            const danNames = appBoardFlipped ?
                ['九', '八', '七', '六', '五', '四', '三', '二', '一'] :
                ['一', '二', '三', '四', '五', '六', '七', '八', '九'];
            
            for (let row = 0; row < 9; row++) {
                // Create each cell
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'app-cell';
                    // Store original row/col for internal logic
                    cell.dataset.originalRow = row;
                    cell.dataset.originalCol = col;
                    cell.onclick = () => appHandleCellClick(row, col);
                    boardWithCoords.appendChild(cell);
                }
                
                // Right-side row numbers (段) - Change based on flip state
                const rowLabel = document.createElement('div');
                rowLabel.className = 'app-coord-label';
                rowLabel.textContent = danNames[row];
                boardWithCoords.appendChild(rowLabel);
            }
            
            boardContainer.appendChild(boardWithCoords);
            boardSection.insertBefore(boardContainer, boardSection.firstChild);
        }

        // Function to create the piece palette
        function appCreatePiecesPalette() {
            const palette = document.getElementById('appPiecesPalette');
            palette.innerHTML = '';
            
            Object.entries(appPieces).forEach(([key, name]) => {
                const btn = document.createElement('div');
                btn.className = 'app-piece-btn';
                btn.textContent = name;
                btn.dataset.piece = key;
                btn.onclick = () => appSelectPiece(key, btn);
                
                if (key.startsWith('+')) {
                    btn.classList.add('special-red');
                } else if (key === 'B' || key === 'R') {
                    btn.classList.add('special-blue');
                } else if (key === 'K') {
                    btn.classList.add('special-yellow');
                }
                
                palette.appendChild(btn);
            });
            
            appUpdatePieceAvailability();
        }

        // Function to update the board display
        function appUpdateBoard() {
            const cells = document.querySelectorAll('.app-cell');
            cells.forEach((cell) => {
                const originalRow = parseInt(cell.dataset.originalRow);
                const originalCol = parseInt(cell.dataset.originalCol);
                
                // Determine the actual piece to display based on flip state
                const displayRow = appBoardFlipped ? 8 - originalRow : originalRow;
                const displayCol = appBoardFlipped ? 8 - originalCol : originalCol;

                const piece = appBoard[displayRow][displayCol];
                
                if (piece && piece.piece && piece.player !== undefined) {
                    const pieceName = appPieces[piece.piece] || piece.piece;
                    
                    let colorClass;
                    let rotationClass = '';

                    // When board is flipped, show colors in reverse
                    if (appBoardFlipped) {
                        // Flip the color display: Sente shows as red, Gote shows as blue
                        colorClass = piece.player ? 'gote' : 'sente'; 
                    } else {
                        // Normal display: Sente shows as red, Gote shows as blue
                        colorClass = piece.player ? 'sente' : 'gote'; 
                    }

                    // Determine if the piece graphic should be rotated 180 degrees
                    if (appBoardFlipped) {
                        // In flipped view
                        if (piece.player) {
                            // Sente pieces - rotated in flipped view (facing down)
                            rotationClass = 'rotated-graphic';
                        } else {
                            // Gote pieces - upright in flipped view (facing up)
                            rotationClass = '';
                        }
                    } else {
                        // In normal view
                        if (piece.player) {
                            // Sente pieces - upright in normal view (facing up)
                            rotationClass = '';
                        } else {
                            // Gote pieces - rotated in normal view (facing down)
                            rotationClass = 'rotated-graphic';
                        }
                    }

                    cell.innerHTML = `<span class="app-piece ${colorClass} ${rotationClass}">${pieceName}</span>`;
                } else {
                    cell.innerHTML = '';
                }
                
                // Reset special classes
                cell.classList.remove('invalid', 'pickup-source');
            });
        }

        // Handle cell click event
        function appHandleCellClick(originalRow, originalCol) {
            // Convert original coordinates to current board orientation for logic
            const logicRow = appBoardFlipped ? 8 - originalRow : originalRow;
            const logicCol = appBoardFlipped ? 8 - originalCol : originalCol;

            // If a piece is picked up, place it
            if (appPickedUpPiece) {
                appPlacePickedUpPiece(logicRow, logicCol);
                return;
            }

            // If a piece is selected from palette, place it
            if (appSelectedPiece) {
                appPlacePiece(logicRow, logicCol);
                return;
            }

            // Otherwise, pick up a piece from the board
            const piece = appBoard[logicRow][logicCol];
            if (piece && piece.piece) {
                appPickUpPiece(logicRow, logicCol);
            }
        }

        // Check if placing a pawn would create 2歩 (double pawn)
        function appCheckDoubledPawn(row, col, player) {
            // Only check for pawn pieces
            if (appSelectedPiece !== 'P') return false;
            
            // Check if there's already a pawn of the same player in this column
            for (let r = 0; r < 9; r++) {
                if (r === row) continue; // Skip the target position
                const piece = appBoard[r][col];
                if (piece && piece.piece === 'P' && piece.player === player) {
                    return true; // Found another pawn in the same column
                }
            }
            return false;
        }
        // Function to place a piece (from palette)
        function appPlacePiece(row, col) {
            if (!appSelectedPiece) return;

            // Check for 2歩 (double pawn)
            if (appCheckDoubledPawn(row, col, appCurrentPlayer)) {
                appShowMessage('2歩は反則です', 'error');
                // Add visual feedback
                const displayRow = appBoardFlipped ? 8 - row : row;
                const displayCol = appBoardFlipped ? 8 - col : col;
                const cell = document.querySelector(`[data-original-row="${displayRow}"][data-original-col="${displayCol}"]`);
                if (cell) {
                    cell.classList.add('invalid');
                    setTimeout(() => cell.classList.remove('invalid'), 500);
                }
                return;
            }

            // If there's already a piece, capture it
            const existingPiece = appBoard[row][col];
            if (existingPiece && existingPiece.piece) {
                appAddToCaptured(existingPiece.piece, !existingPiece.player);
            }

            // Check for promotion
            const shouldPromote = appShouldPromote(appSelectedPiece, row, appCurrentPlayer);
            
            if (shouldPromote === 'force') {
                // Forced promotion
                const promotedPiece = '+' + appSelectedPiece;
                appBoard[row][col] = { piece: promotedPiece, player: appCurrentPlayer };
                appPlayPieceSound();
                appShowMessage(`${appPieces[promotedPiece]}を配置しました（強制成り）`);
            } else if (shouldPromote === 'optional' && !appAutoPromoteEnabled) {
                // Show promotion dialog for optional promotion
                appPendingPromotion = { piece: appSelectedPiece, row, col, player: appCurrentPlayer };
                appShowPromoteDialog();
                return;
            } else {
                // Normal placement (no promotion if auto-promote is disabled)
                appBoard[row][col] = { piece: appSelectedPiece, player: appCurrentPlayer };
                appPlayPieceSound();
                appShowMessage(`${appPieces[appSelectedPiece]}を配置しました`);
            }

            appSelectedPiece = null;
            document.querySelectorAll('.app-piece-btn').forEach(btn => btn.classList.remove('selected'));
            appUpdateBoard();
            appUpdateCaptured();
            appUpdatePieceAvailability();
            appUpdateSfen();
        }

        // Function to pick up a piece from the board
        function appPickUpPiece(row, col) {
            const piece = appBoard[row][col];
            if (!piece || !piece.piece) return;

            appPickedUpPiece = { ...piece, sourceRow: row, sourceCol: col };
            appBoard[row][col] = null;
            
            // Highlight the original position (using original coordinates for display)
            const displayRow = appBoardFlipped ? 8 - row : row;
            const displayCol = appBoardFlipped ? 8 - col : col;
            const cell = document.querySelector(`[data-original-row="${displayRow}"][data-original-col="${displayCol}"]`);
            if (cell) {
                cell.classList.add('pickup-source');
            }
            
            appPlayPieceSound();
            appShowPieceIndicator();
            appUpdateBoard();
            appUpdateSfen();
        }

        // Function to place a picked-up piece
        function appPlacePickedUpPiece(row, col) {
            if (!appPickedUpPiece) return;

            // If placing back to the original position
            if (row === appPickedUpPiece.sourceRow && col === appPickedUpPiece.sourceCol) {
                appBoard[row][col] = { piece: appPickedUpPiece.piece, player: appPickedUpPiece.player };
                appPickedUpPiece = null;
                appHidePieceIndicator();
                appUpdateBoard();
                appUpdateSfen();
                appShowMessage('駒を元の位置に戻しました');
                return;
            }

            // If there's already a piece, capture it
            const existingPiece = appBoard[row][col];
            if (existingPiece && existingPiece.piece) {
                appAddToCaptured(existingPiece.piece, !existingPiece.player);
            }

            // Check for promotion
            const shouldPromote = appShouldPromote(appPickedUpPiece.piece, row, appPickedUpPiece.player);
            
            if (shouldPromote === 'force') {
                // Forced promotion
                const promotedPiece = '+' + appPickedUpPiece.piece;
                appBoard[row][col] = { piece: promotedPiece, player: appPickedUpPiece.player };
                appShowMessage(`${appPieces[promotedPiece]}を移動しました（強制成り）`);
            } else if (shouldPromote === 'optional' && !appAutoPromoteEnabled) {
                // Show promotion dialog for optional promotion
                appPendingPromotion = { 
                    piece: appPickedUpPiece.piece, 
                    row, 
                    col, 
                    player: appPickedUpPiece.player,
                    isMove: true // Indicate this is a move, not a placement from palette
                };
                appShowPromoteDialog();
                return;
            } else {
                // Normal move
                appBoard[row][col] = { piece: appPickedUpPiece.piece, player: appPickedUpPiece.player };
                appShowMessage(`${appPieces[appPickedUpPiece.piece]}を移動しました`);
            }

            appPickedUpPiece = null;
            appHidePieceIndicator();
            appPlayPieceSound();
            appUpdateBoard();
            appUpdateCaptured();
            appUpdateSfen();
        }

        // Promotion check logic
        function appShouldPromote(piece, row, player) {
            if (piece.startsWith('+')) return 'none'; // Already promoted
            if (piece === 'K' || piece === 'G') return 'none'; // King and Gold cannot promote

            const promotionZone = player ? [0, 1, 2] : [6, 7, 8]; // Sente: ranks 1-3, Gote: ranks 7-9
            
            if (promotionZone.includes(row)) {
                // Forced promotion check
                if ((piece === 'P' || piece === 'L') && 
                    ((player && row === 0) || (!player && row === 8))) {
                    return 'force'; // Pawn/Lance reaching last rank
                }
                if (piece === 'N' && 
                    ((player && (row === 0 || row === 1)) || (!player && (row === 7 || row === 8)))) {
                    return 'force'; // Knight reaching last two ranks
                }
                return 'optional'; // Optional promotion
            }
            
            return 'none'; // No promotion
        }

        // Show promotion dialog
        function appShowPromoteDialog() {
            const dialog = document.getElementById('appPromoteDialog');
            dialog.style.display = 'flex';
            setTimeout(() => dialog.classList.add('show'), 10);
        }

        // Hide promotion dialog
        function appHidePromoteDialog() {
            const dialog = document.getElementById('appPromoteDialog');
            dialog.classList.remove('show');
            setTimeout(() => dialog.style.display = 'none', 300);
        }

        // Show piece indicator when a piece is picked up
        function appShowPieceIndicator() {
            if (!appPickedUpPiece) return;
            
            let indicator = document.querySelector('.app-piece-indicator');
            if (!indicator) {
                // Create indicator if it doesn't exist
                indicator = document.createElement('div');
                indicator.className = 'app-piece-indicator';
                indicator.onclick = appReturnPickedUpPiece; // Clicking indicator returns piece to original spot
                document.body.appendChild(indicator);
            }
            
            const pieceName = appPieces[appPickedUpPiece.piece];
            const playerName = appPickedUpPiece.player ? '先手' : '後手';
            indicator.innerHTML = `${playerName}の${pieceName}を持っています`;
            indicator.classList.add('show');
            
            const returnBtn = document.getElementById('appReturnToPaletteBtn');
            returnBtn.classList.add('show');
        }

        // Hide piece indicator
        function appHidePieceIndicator() {
            const indicator = document.querySelector('.app-piece-indicator');
            const returnBtn = document.getElementById('appReturnToPaletteBtn');
            
            if (indicator) {
                indicator.classList.remove('show');
            }
            if (returnBtn) {
                returnBtn.classList.remove('show');
            }
        }

        // Return picked-up piece to its original position on the board
        function appReturnPickedUpPiece() {
            if (!appPickedUpPiece) return;
            
            // Convert source coordinates back to logical board coordinates
            const logicalSourceRow = appPickedUpPiece.sourceRow;
            const logicalSourceCol = appPickedUpPiece.sourceCol;

            appBoard[logicalSourceRow][logicalSourceCol] = {
                piece: appPickedUpPiece.piece,
                player: appPickedUpPiece.player
            };
            
            appPickedUpPiece = null;
            appHidePieceIndicator();
            appUpdateBoard();
            appUpdateSfen();
            appShowMessage('駒を元の位置に戻しました');
        }

        // Return picked-up piece to the palette (remove from game)
        function appReturnPickedUpPieceToCapture() {
            if (!appPickedUpPiece) return;
            
            // Simply remove the piece from the game (return to palette)
            appPickedUpPiece = null;
            appHidePieceIndicator();
            appUpdatePieceAvailability(); // Update piece availability since one piece was removed
            appUpdateSfen();
            appShowMessage('駒をパレットに戻しました');
        }

        // Add piece to captured pieces
        function appAddToCaptured(piece, player) {
            const basePiece = piece.replace('+', '');
            const targetPlayer = player ? 'sente' : 'gote';
            appCapturedPieces[targetPlayer][basePiece] = (appCapturedPieces[targetPlayer][basePiece] || 0) + 1;
        }

        // Update captured pieces display for both players
        function appUpdateCaptured() {
            appUpdateCapturedForPlayer('sente');
            appUpdateCapturedForPlayer('gote');
        }

        // Update captured pieces display for a specific player
        function appUpdateCapturedForPlayer(player) {
            const container = document.getElementById(player === 'sente' ? 'appSenteCaptured' : 'appGoteCaptured');
            container.innerHTML = '';
            
            const pieces = appCapturedPieces[player];
            appSfenPieceOrder.forEach(piece => {
                const count = pieces[piece] || 0;
                for (let i = 0; i < count; i++) {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = `app-captured-piece ${player}`;
                    pieceElement.textContent = appPieces[piece];
                    pieceElement.onclick = () => appUseCapturedPiece(piece, player, pieceElement);
                    container.appendChild(pieceElement);
                }
            });
            
            // Add click handler to the container for adding pieces from palette or picked-up pieces
            container.onclick = (e) => {
                if (e.target === container) {
                    if (appSelectedPiece) {
                        appAddPieceFromPalette(player);
                    } else if (appPickedUpPiece) {
                        appAddPickedUpPieceToCapture(player);
                    }
                }
            };
        }

        // Add picked-up piece from board to captured pieces
        function appAddPickedUpPieceToCapture(targetPlayer) {
            if (!appPickedUpPiece) return;
            
            const basePiece = appPickedUpPiece.piece.replace('+', ''); // Get base piece (e.g., 'P' from '+P')
            
            // Kings cannot be added to captured pieces
            if (basePiece === 'K') {
                appShowMessage('玉は持ち駒にできません', 'warning');
                // Return piece to original position
                appReturnPickedUpPiece();
                return;
            }
            
            // Add the base piece to captured pieces
            appCapturedPieces[targetPlayer][basePiece] = (appCapturedPieces[targetPlayer][basePiece] || 0) + 1;
            
            appPickedUpPiece = null;
            appHidePieceIndicator();
            appUpdateCaptured();
            appUpdatePieceAvailability();
            appUpdateSfen();
            appPlayPieceSound();
            appShowMessage(`${appPieces[basePiece]}を${targetPlayer === 'sente' ? '先手' : '後手'}の持ち駒に追加しました`);
        }

        // Add piece from palette to captured pieces
        function appAddPieceFromPalette(targetPlayer) {
            if (!appSelectedPiece) return;
            
            // Check if the piece can be added (not exceeding max count)
            const basePiece = appSelectedPiece.replace('+', ''); // Get base piece for counting
            
            // Kings cannot be added to captured pieces
            if (basePiece === 'K') {
                appShowMessage('玉は持ち駒にできません', 'warning');
                return;
            }
            
            const pieceCount = appCountPiecesOnBoard();
            const capturedSente = appCapturedPieces.sente[basePiece] || 0;
            const capturedGote = appCapturedPieces.gote[basePiece] || 0;
            const totalUsed = (pieceCount[basePiece] || 0) + capturedSente + capturedGote;
            
            if (appMaxPieces[basePiece] && totalUsed >= appMaxPieces[basePiece]) {
                appShowMessage('この駒はもう配置できません', 'warning');
                return;
            }
            
            // Add the base piece (not promoted) to captured pieces
            appCapturedPieces[targetPlayer][basePiece] = (appCapturedPieces[targetPlayer][basePiece] || 0) + 1;
            
            // Clear selection
            appSelectedPiece = null;
            document.querySelectorAll('.app-piece-btn').forEach(btn => btn.classList.remove('selected'));
            
            // Update displays
            appUpdateCaptured();
            appUpdatePieceAvailability();
            appUpdateSfen();
            appPlayPieceSound();
            appShowMessage(`${appPieces[basePiece]}を${targetPlayer === 'sente' ? '先手' : '後手'}の持ち駒に追加しました`);
        }
        // Use a captured piece (place it on the board)
        function appUseCapturedPiece(piece, player, element) {
            if (appCapturedPieces[player][piece] > 0) {
                appCapturedPieces[player][piece]--;
                if (appCapturedPieces[player][piece] === 0) {
                    delete appCapturedPieces[player][piece];
                }
                
                // When board is flipped, the actual player should be opposite of the visual player
                const actualPlayer = appBoardFlipped ? 
                    (player === 'sente' ? false : true) : // If flipped: sente display = gote actual, gote display = sente actual
                    (player === 'sente' ? true : false);  // If normal: sente display = sente actual, gote display = gote actual
                
                appCurrentPlayer = actualPlayer; // Set current player to the actual player
                appSelectedPiece = piece; // Set the selected piece to the captured piece
                
                // Update palette selection
                document.querySelectorAll('.app-piece-btn').forEach(btn => btn.classList.remove('selected'));
                const paletteBtn = document.querySelector(`[data-piece="${piece}"]`);
                if (paletteBtn) paletteBtn.classList.add('selected');
                
                appUpdatePlayerToggle();
                appUpdateCaptured();
                appUpdatePieceAvailability();
                appUpdateSfen();
                appPlayPieceSound();
                appShowMessage(`${appPieces[piece]}を選択しました`);
            }
        }

        // Update piece availability in the palette (disable if max count reached)
        function appUpdatePieceAvailability() {
            const pieceCount = appCountPiecesOnBoard();
            
            document.querySelectorAll('.app-piece-btn').forEach(btn => {
                const piece = btn.dataset.piece;
                const basePiece = piece.replace('+', ''); // Get base piece for promoted pieces too
                const count = pieceCount[basePiece] || 0;
                const capturedSente = appCapturedPieces.sente[basePiece] || 0;
                const capturedGote = appCapturedPieces.gote[basePiece] || 0;
                const totalUsed = count + capturedSente + capturedGote;
                
                btn.classList.remove('disabled');
                
                // Disable King if max kings per player reached
                if (basePiece === 'K') {
                    const senteKings = appCountKingsForPlayer(true);
                    const goteKings = appCountKingsForPlayer(false);
                    if ((appCurrentPlayer && senteKings >= appMaxKingPerPlayer) || 
                        (!appCurrentPlayer && goteKings >= appMaxKingPerPlayer)) {
                        btn.classList.add('disabled');
                    }
                } else if (appMaxPieces[basePiece] && totalUsed >= appMaxPieces[basePiece]) {
                    // Disable other pieces if max count reached
                    btn.classList.add('disabled');
                }
            });
        }

        // Count pieces on the board
        function appCountPiecesOnBoard() {
            const count = {};
            appBoard.forEach(row => {
                row.forEach(cell => {
                    if (cell && cell.piece) {
                        const basePiece = cell.piece.replace('+', ''); // Count base piece, not promoted
                        count[basePiece] = (count[basePiece] || 0) + 1;
                    }
                });
            });
            return count;
        }

        // Count kings for a specific player
        function appCountKingsForPlayer(player) {
            let count = 0;
            appBoard.forEach(row => {
                row.forEach(cell => {
                    if (cell && cell.piece === 'K' && cell.player === player) {
                        count++;
                    }
                });
            });
            return count;
        }

        // Update player toggle display
        function appUpdatePlayerToggle() {
            const label = document.getElementById('appPlayerLabel');
            const toggle = document.getElementById('appPlayerToggle');
            
            // When board is flipped, show the opposite player in the toggle
            const displayPlayer = appBoardFlipped ? !appCurrentPlayer : appCurrentPlayer;
            
            if (displayPlayer) {
                label.textContent = '先手';
                toggle.classList.remove('active');
            } else {
                label.textContent = '後手';
                toggle.classList.add('active');
            }
        }

        // Update promotion setting toggle display
        function appUpdatePromoteToggle() {
            const label = document.getElementById('appPromoteLabel');
            const toggle = document.getElementById('appPromoteToggle');
            
            if (appAutoPromoteEnabled) {
                label.textContent = '成らない';
                toggle.classList.add('active');
            } else {
                label.textContent = '成 / 不成';
                toggle.classList.remove('active');
            }
        }

        // Update sound toggle display
        function appUpdateSoundToggle() {
            const label = document.getElementById('appSoundLabel');
            const toggle = document.getElementById('appSoundToggle');
            
            if (appSoundEnabled) {
                label.textContent = 'オン';
                toggle.classList.add('active');
            } else {
                label.textContent = 'オフ';
                toggle.classList.remove('active');
            }
        }

        // Generate SFEN string
        function appGenerateSfen(turn = 'b') { // Default turn is 'b' (black/sente)
            let sfen = '';
            
            // Board part
            for (let row = 0; row < 9; row++) {
                let emptyCount = 0;
                for (let col = 0; col < 9; col++) {
                    const piece = appBoard[row][col];
                    if (piece && piece.piece) {
                        if (emptyCount > 0) {
                            sfen += emptyCount;
                            emptyCount = 0;
                        }
                        let pieceChar = piece.piece;
                        if (!piece.player) { // If Gote, convert to lowercase
                            pieceChar = pieceChar.toLowerCase();
                        }
                        sfen += pieceChar;
                    } else {
                        emptyCount++;
                    }
                }
                if (emptyCount > 0) {
                    sfen += emptyCount;
                }
                if (row < 8) {
                    sfen += '/';
                }
            }
            
            sfen += ` ${turn} `; // Add turn information
            
            // Captured pieces part
            let handStr = '';
            ['sente', 'gote'].forEach(player => {
                const pieces = appCapturedPieces[player];
                appSfenPieceOrder.forEach(piece => {
                    const count = pieces[piece] || 0;
                    if (count > 0) {
                        let pieceChar = piece;
                        if (player === 'gote') {
                            pieceChar = pieceChar.toLowerCase();
                        }
                        if (count > 1) {
                            handStr += count;
                        }
                        handStr += pieceChar;
                    }
                });
            });
            
            sfen += handStr || '-'; // If no captured pieces, use '-'
            sfen += ' 1'; // Move number (always 1 for initial setup)
            
            return sfen;
        }

        // Update SFEN display
        function appUpdateSfen() {
            const sfenText = document.getElementById('appSfenText');
            // When SFEN is generated, it should reflect the current logical board state, not the flipped visual state.
            // The turn in SFEN is independent of the visual flip.
            sfenText.textContent = appGenerateSfen(appCurrentPlayer ? 'b' : 'w'); 
        }

        // Import SFEN string
        function appImportSfen() {
            // Create a custom input dialog
            const dialog = document.createElement('div');
            dialog.className = 'app-turn-dialog show';
            dialog.innerHTML = `
                <div class="app-turn-dialog-content" style="width: 400px; max-width: 95%;">
                    <div class="app-turn-dialog-header">SFEN文字列を入力してください</div>
                    <textarea id="sfenInput" style="width: 100%; height: 80px; margin: 10px 0; padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-family: monospace; font-size: 12px;" placeholder="例: lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1"></textarea>
                    <div class="app-turn-dialog-buttons">
                        <button class="app-turn-btn sente" id="importSfenOk">インポート</button>
                        <button class="app-turn-btn gote" id="importSfenCancel">キャンセル</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);

            document.getElementById('sfenInput').focus();
            
            document.getElementById('importSfenOk').onclick = () => {
                const sfenInput = document.getElementById('sfenInput').value.trim();
                document.body.removeChild(dialog);
                
                if (!sfenInput) {
                    appShowMessage('SFEN文字列が入力されていません', 'error');
                    return;
                }
                
                try {
                    appParseSfen(sfenInput);
                    appShowMessage('SFEN文字列をインポートしました', 'success');
                } catch (error) {
                    appShowMessage('SFEN文字列の形式が正しくありません', 'error');
                    console.error('SFEN parse error:', error);
                }
            };
            
            document.getElementById('importSfenCancel').onclick = () => {
                document.body.removeChild(dialog);
            };
        }

        // Parse SFEN string and update board state
        function appParseSfen(sfen) {
            const parts = sfen.split(' ');
            if (parts.length < 3) throw new Error('Invalid SFEN format');
            
            const [boardPart, turnPart, handPart] = parts;
            
            // Clear board and captured pieces
            appBoard = Array(9).fill(null).map(() => Array(9).fill(null));
            appCapturedPieces = { sente: {}, gote: {} };
            
            // Parse board part
            const rows = boardPart.split('/');
            if (rows.length !== 9) throw new Error('Invalid board format');
            
            rows.forEach((row, rowIndex) => {
                let colIndex = 0;
                for (let i = 0; i < row.length; i++) {
                    const char = row[i];
                    if (/\d/.test(char)) { // If character is a number, it represents empty cells
                        colIndex += parseInt(char);
                    } else {
                        let pieceChar = char;
                        if (char === '+') { // Handle promoted pieces
                            i++;
                            pieceChar += row[i];
                        }
                        const piece = pieceChar.toUpperCase();
                        const isGote = pieceChar === pieceChar.toLowerCase(); // Check if piece is Gote (lowercase)
                        
                        appBoard[rowIndex][colIndex] = {
                            piece: piece,
                            player: !isGote // true for Sente, false for Gote
                        };
                        colIndex++;
                    }
                }
            });
            
            // Parse captured pieces part
            if (handPart !== '-') {
                for (let i = 0; i < handPart.length; i++) {
                    const char = handPart[i];
                    if (/\d/.test(char)) { // If character is a number, it's a count
                        const count = parseInt(char);
                        const piece = handPart[i + 1].toUpperCase();
                        const isGote = handPart[i + 1] === handPart[i + 1].toLowerCase();
                        const player = isGote ? 'gote' : 'sente';
                        
                        appCapturedPieces[player][piece] = count;
                        i++; // Skip the piece character as it's paired with the count
                    } else {
                        const piece = char.toUpperCase();
                        const isGote = char === char.toLowerCase();
                        const player = isGote ? 'gote' : 'sente';
                        
                        appCapturedPieces[player][piece] = (appCapturedPieces[player][piece] || 0) + 1;
                    }
                }
            }
            
            // Set current player based on SFEN turn part
            appCurrentPlayer = (turnPart === 'b');

            // Update UI
            appCreateBoard(); // Recreate board to update coordinates based on appBoardFlipped state
            appUpdateBoard();
            appUpdateCaptured();
            appUpdatePieceAvailability();
            appUpdatePlayerToggle(); // Update player toggle label
            appUpdateSfen();
        }

        // Set initial Shogi position
        function appSetInitialPosition() {
            appBoard = Array(9).fill(null).map(() => Array(9).fill(null));
            appCapturedPieces = { sente: {}, gote: {} };
            
            // Place Sente pieces
            const senteBackRank = ['L', 'N', 'S', 'G', 'K', 'G', 'S', 'N', 'L'];
            senteBackRank.forEach((piece, col) => {
                appBoard[8][col] = { piece, player: true };
            });
            
            appBoard[7][1] = { piece: 'R', player: true }; // Sente Rook
            appBoard[7][7] = { piece: 'B', player: true }; // Sente Bishop
            
            for (let col = 0; col < 9; col++) {
                appBoard[6][col] = { piece: 'P', player: true }; // Sente Pawns
            }
            
            // Place Gote pieces
            const goteBackRank = ['L', 'N', 'S', 'G', 'K', 'G', 'S', 'N', 'L'];
            goteBackRank.forEach((piece, col) => {
                appBoard[0][col] = { piece, player: false };
            });
            
            appBoard[1][7] = { piece: 'R', player: false }; // Gote Rook
            appBoard[1][1] = { piece: 'B', player: false }; // Gote Bishop
            
            for (let col = 0; col < 9; col++) {
                appBoard[2][col] = { piece: 'P', player: false }; // Gote Pawns
            }
            
            appUpdateBoard();
            appUpdateCaptured();
            appUpdatePieceAvailability();
            appUpdateSfen();
            appShowMessage('初期配置を設定しました');
        }

        // Custom confirmation modal function (replaces alert/confirm)
        function appShowConfirmationDialog(message, onConfirm, onCancel) {
            const dialog = document.createElement('div');
            dialog.className = 'app-turn-dialog show'; // Reuse dialog styles
            dialog.innerHTML = `
                <div class="app-turn-dialog-content">
                    <div class="app-turn-dialog-header">${message}</div>
                    <div class="app-turn-dialog-buttons">
                        <button class="app-turn-btn sente confirm-yes">はい</button>
                        <button class="app-turn-btn gote confirm-no">いいえ</button>
                    </div>
                </div>
            `;
            document.body.appendChild(dialog);

            dialog.querySelector('.confirm-yes').onclick = () => {
                document.body.removeChild(dialog);
                onConfirm();
            };
            dialog.querySelector('.confirm-no').onclick = () => {
                document.body.removeChild(dialog);
                onCancel();
            };
        }

        // Clear the entire board
        function appClearBoard() {
            appShowConfirmationDialog('盤面をクリアしますか？', () => {
                appBoard = Array(9).fill(null).map(() => Array(9).fill(null));
                appCapturedPieces = { sente: {}, gote: {} };
                appSelectedPiece = null;
                appPickedUpPiece = null;
                
                document.querySelectorAll('.app-piece-btn').forEach(btn => btn.classList.remove('selected'));
                appHidePieceIndicator();
                
                appUpdateBoard();
                appUpdateCaptured();
                appUpdatePieceAvailability();
                appUpdateSfen();
                appShowMessage('盤面をクリアしました');
            }, () => {
                // Do nothing if cancelled
            });
        }

        // Move remaining pieces to Gote's captured pieces
        function appMoveRemainingPieces() {
            const totalPieces = appCountPiecesOnBoard();
            const capturedSente = appCapturedPieces.sente;
            const capturedGote = appCapturedPieces.gote;
            
            Object.entries(appMaxPieces).forEach(([piece, maxCount]) => {
                const used = (totalPieces[piece] || 0) + (capturedSente[piece] || 0) + (capturedGote[piece] || 0);
                const remaining = maxCount - used;
                
                if (remaining > 0) {
                    appCapturedPieces.gote[piece] = (appCapturedPieces.gote[piece] || 0) + remaining;
                }
            });
            
            appUpdateCaptured();
            appUpdatePieceAvailability();
            appUpdateSfen();
            appShowMessage('余り駒を後手持ち駒に移動しました');
        }

        // Clear captured pieces for a specific player
        function appClearCapturedPieces(player) {
            appShowConfirmationDialog(`${player === 'sente' ? '先手' : '後手'}の持ち駒をクリアしますか？`, () => {
                appCapturedPieces[player] = {};
                appUpdateCaptured();
                appUpdatePieceAvailability();
                appUpdateSfen();
                appShowMessage(`${player === 'sente' ? '先手' : '後手'}の持ち駒をクリアしました`);
            }, () => {
                // Do nothing if cancelled
            });
        }

        // Play a piece sound
        function appPlayPieceSound() {
            if (!appSoundEnabled) return; // Only play sound if enabled
            
            try {
                if (!appAudioContext) {
                    appAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const oscillator = appAudioContext.createOscillator();
                const gainNode = appAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(appAudioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, appAudioContext.currentTime);
                gainNode.gain.setValueAtTime(0.1, appAudioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, appAudioContext.currentTime + 0.1);
                
                oscillator.start(appAudioContext.currentTime);
                oscillator.stop(appAudioContext.currentTime + 0.1);
            } catch (error) {
                // Ignore if audio cannot be played (e.g., no user interaction yet)
            }
        }

        // Show turn selection dialog for export actions
        function appShowTurnDialog(action) {
            appPendingExportAction = action;
            const dialog = document.getElementById('appTurnDialog');
            dialog.style.display = 'flex';
            setTimeout(() => dialog.classList.add('show'), 10);
        }

        // Hide turn selection dialog
        function appHideTurnDialog() {
            const dialog = document.getElementById('appTurnDialog');
            dialog.classList.remove('show');
            setTimeout(() => dialog.style.display = 'none', 300);
        }

        // Generate share URL
        function appGenerateShareUrl(turn = 'b') {
            const sfen = appGenerateSfen(turn);
            const sfenPosition = `position sfen ${sfen}`;
            const encodedSfen = encodeURIComponent(sfenPosition);
            return `https://www.studiok-i.net/kifu/?sfen=${encodedSfen}`;
        }

        // Generate PiyoShogi URL
        function appGeneratePiyoShogiUrl(turn = 'b') {
            const sfen = appGenerateSfen(turn);
            const sfenPosition = `position sfen ${sfen}`;
            const encodedSfen = encodeURIComponent(sfenPosition);
            return `piyoshogi://?sfen=${encodedSfen}`;
        }

        // Flip the board - FIXED VERSION
        function appFlipBoard() {
            appBoardFlipped = !appBoardFlipped; // Toggle flip state

            // Flip captured pieces (swap sente and gote)
            const tempCaptured = { ...appCapturedPieces.sente };
            appCapturedPieces.sente = { ...appCapturedPieces.gote };
            appCapturedPieces.gote = tempCaptured;
            
            // Flip current player
            appCurrentPlayer = !appCurrentPlayer;
            
            // Recreate board UI to update display
            appCreateBoard(); 
            appUpdateBoard();
            appUpdateCaptured(); // Update captured pieces display
            appUpdatePlayerToggle(); // Update player toggle display
            appUpdateSfen();
            appShowMessage(appBoardFlipped ? '盤面を反転しました' : '盤面を元に戻しました');
        }

        // Function to call Gemini API for board analysis
        async function appAnalyzeBoard() {
            const sfen = appGenerateSfen(appCurrentPlayer ? 'b' : 'w');
            const analysisOutput = document.getElementById('appAnalysisOutput');
            const analysisText = document.getElementById('appAnalysisText');

            analysisOutput.style.display = 'block';
            analysisText.textContent = '解説を生成中...';
            analysisOutput.classList.add('loading');
            appShowMessage('局面を分析しています...', 'warning');

            const prompt = `将棋のSFEN形式の局面データが与えられます。この局面について、日本語で戦略的な解説を行ってください。先手と後手のどちらが有利か、主要な駒の配置、攻め筋、守り筋、持ち駒の状況などを具体的に説明してください。SFEN: ${sfen}`;

            try {
                let chatHistory = [];
                chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                const payload = { contents: chatHistory };
                const apiKey = ""; // If you want to use models other than gemini-2.0-flash or imagen-3.0-generate-002, provide an API key here. Otherwise, leave this as-is.
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    analysisText.textContent = text;
                    appShowMessage('局面の解説が完了しました');
                } else {
                    analysisText.textContent = '解説を生成できませんでした。';
                    appShowMessage('解説生成に失敗しました', 'error');
                }
            } catch (error) {
                console.error('Error calling Gemini API:', error);
                analysisText.textContent = '解説の取得中にエラーが発生しました。ネットワーク接続を確認してください。';
                appShowMessage('解説取得中にエラーが発生しました', 'error');
            } finally {
                analysisOutput.classList.remove('loading');
            }
        }

        // Set up event listeners for all interactive elements
        function appSetupEventListeners() {
            // Player toggle
            document.getElementById('appPlayerToggle').onclick = () => {
                appCurrentPlayer = !appCurrentPlayer;
                appUpdatePlayerToggle();
            };
            
            // Promotion setting toggle
            document.getElementById('appPromoteToggle').onclick = () => {
                appAutoPromoteEnabled = !appAutoPromoteEnabled;
                appUpdatePromoteToggle();
            };
            
            // Button events
            document.getElementById('appCopySfenBtn').onclick = () => appShowTurnDialog('copy');
            document.getElementById('appImportSfenBtn').onclick = appImportSfen;
            document.getElementById('appGenerateShareBtn').onclick = () => appShowTurnDialog('share');
            document.getElementById('appPiyoshogiBtn').onclick = () => appShowTurnDialog('piyoshogi');
            document.getElementById('appInitialPositionBtn').onclick = appSetInitialPosition;
            document.getElementById('appMoveRemainingBtn').onclick = appMoveRemainingPieces;
            document.getElementById('appFlipBoardBtn').onclick = appFlipBoard; // Fixed flip board button
            document.getElementById('appClearBoardBtn').onclick = appClearBoard;
            
            // Clear captured pieces buttons
            document.getElementById('appClearSenteBtn').onclick = () => appClearCapturedPieces('sente');
            document.getElementById('appClearGoteBtn').onclick = () => appClearCapturedPieces('gote');
            
            // Button to return picked-up piece to captured pieces
            document.getElementById('appReturnToPaletteBtn').onclick = appReturnPickedUpPieceToCapture;
            
            // Turn selection dialog buttons
            document.getElementById('appTurnSenteBtn').onclick = () => {
                appExecuteExportAction('b'); // 'b' for Sente (Black)
                appHideTurnDialog();
            };
            document.getElementById('appTurnGoteBtn').onclick = () => {
                appExecuteExportAction('w'); // 'w' for Gote (White)
                appHideTurnDialog();
            };
            
            // Promotion choice dialog buttons
            document.getElementById('appPromoteYesBtn').onclick = () => {
                appExecutePromotion(true); // Promote
                appHidePromoteDialog();
            };
            document.getElementById('appPromoteNoBtn').onclick = () => {
                appExecutePromotion(false); // Do not promote
                appHidePromoteDialog();
            };
        }

        // Execute the pending export action (copy, share, piyoshogi)
        function appExecuteExportAction(turn) {
            const sfen = appGenerateSfen(turn);
            
            switch (appPendingExportAction) {
                case 'copy':
                    // Use document.execCommand('copy') for clipboard operations in iframe
                    const tempInput = document.createElement('textarea');
                    tempInput.value = sfen;
                    document.body.appendChild(tempInput);
                    tempInput.select();
                    try {
                        document.execCommand('copy');
                        appShowMessage('SFENをクリップボードにコピーしました');
                    } catch (err) {
                        appShowMessage('クリップボードへのコピーに失敗しました', 'error');
                    }
                    document.body.removeChild(tempInput);
                    break;
                    
                case 'share':
                    const shareUrl = appGenerateShareUrl(turn);
                    const tempShareInput = document.createElement('textarea');
                    tempShareInput.value = shareUrl;
                    document.body.appendChild(tempShareInput);
                    tempShareInput.select();
                    try {
                        document.execCommand('copy');
                        appShowMessage('共有URLをクリップボードにコピーしました');
                    } catch (err) {
                        appShowMessage('クリップボードへのコピーに失敗しました', 'error');
                    }
                    document.body.removeChild(tempShareInput);
                    break;
                    
                case 'piyoshogi':
                    const piyoUrlForOpen = appGeneratePiyoShogiUrl(turn);
                    window.open(piyoUrlForOpen, '_blank');
                    appShowMessage('ぴよ将棋を開きました');
                    break;
            }
            
            appPendingExportAction = null;
        }

        // Execute promotion based on user choice
        function appExecutePromotion(promote) {
            if (!appPendingPromotion) return;
            
            const { piece, row, col, player, isMove } = appPendingPromotion;
            const finalPiece = promote ? '+' + piece : piece;
            
            appBoard[row][col] = { piece: finalPiece, player };
            
            const action = isMove ? '移動' : '配置';
            const message = promote ? 
                `${appPieces[finalPiece]}を${action}しました（成り）` : 
                `${appPieces[piece]}を${action}しました`;
            
            // Reset selected/picked-up piece state
            if (!isMove) {
                appSelectedPiece = null;
                document.querySelectorAll('.app-piece-btn').forEach(btn => btn.classList.remove('selected'));
            } else {
                appPickedUpPiece = null;
                appHidePieceIndicator();
            }
            
            appPlayPieceSound();
            appShowMessage(message);
            appUpdateBoard();
            appUpdateCaptured();
            appUpdatePieceAvailability();
            appUpdateSfen();
            
            appPendingPromotion = null;
        }

        // Load SFEN from URL parameters on app startup
        function appLoadFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const sfen = urlParams.get('sfen');
            
            if (sfen) {
                try {
                    appParseSfen(decodeURIComponent(sfen));
                    appShowMessage('URLからSFENを読み込みました', 'success');
                } catch (error) {
                    appShowMessage('URLのSFEN形式が正しくありません', 'error');
                }
            }
        }

        // Application initialization function
        function appInit() {
            appCreateBoard(); // Create the Shogi board UI
            appCreatePiecesPalette(); // Create the piece selection palette
            appSetupEventListeners(); // Set up all interactive event listeners
            appUpdatePlayerToggle(); // Initialize player toggle display
            appUpdatePromoteToggle(); // Initialize promotion toggle display
            appUpdateBoard(); // Initial board render
            appUpdateCaptured(); // Initial captured pieces render
            appUpdatePieceAvailability(); // Initial piece availability check
            appUpdateSfen(); // Initial SFEN string generation
            
            // Load SFEN from URL parameters if present
            appLoadFromUrl();
            
            appShowMessage('詰将棋練習アプリが起動しました');
        }

        // Execute app initialization when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', appInit);
    </script>
</body>
</html>